version: "3.7"
# Si se abre desde el Portainer o 0.0.0.0:4200 no funciona (problema con CORS), ya que es para abrir desde localhost:4200
services:
  # Contenedor de mongo en el cual incluimos como volúmenes la información de la base de datos. Además de que enlazamos el script import.sh al entrypoint para que sea ejecutado este script importa la base de datos que hemos enlazado con el primer volumen.
  mongo_container:
    image: mongo:latest
    container_name: mongo_container

    volumes:
      - ./mongo/dump/mydb:/dump
      - ./mongo/import.sh:/docker-entrypoint-initdb.d/import.sh
    restart: always
    networks:
      - practica_net
  # Este contenedor es el backend de nuestro proyecto, depende del contenedor de mongo.
  backend:
    build: ./backend
    depends_on:
      - mongo_container
    ports:
      - "3001:3001"
    restart: always
    # La aplicación de express arrancará cuando la base de datos esté operativa.
    command: sh -c '/app/wait-for-it.sh -t 0 mongo_container:27017 -- npm run start'
    networks:
      - practica_net

  # Este contenedor es el frontend de nuestro proyecto, depende del contenedor del backend.
  frontend:
    build: ./frontend
    restart: always
    depends_on:
      - backend
    ports:
      - 4200:4200
    networks:
      - practica_net
  # Este contenedor nos administra la base de datos mongo. Utiliza la variable de entorno ME_CONFIG_MONGODB_SERVER la cual contiene la ip o en este caso. También usa la variable ME_CONFIG_MONGODB_ENABLE_ADMIN para poder acceder sin un usuario o contraseña específicos. Estas variables se encuentran en el fichero .env del proyecto Necesita el restart always porque si no da error al no poder conectarse con mongo.
  adminMongo_container:
    image: mongo-express:latest
    networks:
      - practica_net
    restart: always
    env_file:
      - .env
    ports:
      - "8081:8081"
    depends_on:
      - mongo_container

  # Para utilizar el load balancer hemos cambiado el puerto que utiliza el frontend para realizar las peticiones, ahora este es el 8080 y no el 3001. De igual forma, ahora se accede al frontend desde el puerto 8080 y no el 4200.
  loadBalancer:
    image: nginx:latest
    networks:
      - practica_net
    ports:
      - "8080:80"
    restart: always
    volumes:
      - "./loadbalancer/nginx.conf:/etc/nginx/nginx.conf"
    command: nginx -g "daemon off;"

  # Hemos asociado el fichero de configuración y hemos ejecutado el comando para que prometheus utilice este. Hemos usado express-prometheus-middlewareen en el servidor para que prometheus pueda obtener sus métricas.
  prometheus_practica:
    image: prom/prometheus:v2.20.1
    container_name: prometheus_practica
    restart: always
    networks:
      - practica_net
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - --config.file=/etc/prometheus/prometheus.yml

  grafana_practica:
    image: grafana/grafana:7.1.5
    container_name: grafana_practica
    restart: always
    networks:
      - practica_net
    ports:
      - "3500:3000"
    volumes:
      - ./datasources.yml:/etc/grafana/provisioning/datasources/datasources.yml
      - myGrafanaVol:/var/lib/grafana
    env_file:
      - .env
    depends_on:
      - prometheus_practica

  # Los contenedores están en la misma red.
networks:
  practica_net:

# Volumen pedido en la actividad cuya función es almacenar la información de grafana.
volumes:
  myGrafanaVol:
